import json
import os
from typing import List, Optional, Dict, Any
from sqlalchemy.orm import Session
from sqlalchemy import select, insert, delete
from .db.models import User, Question as DBQuestion, Answer as DBAnswer, Tag
from .models import QuestionSummary, PaginatedResponse, SearchRequest, SearchResponse
import math
from datetime import datetime
from sqlalchemy import func
from .db.models import question_tags
from .models import QuestionCreate, AnswerCreate, TagCreate, UserCreate

class DataService:
    def __init__(self, db: Session):
        self.db = db
    
    def get_user_by_id(self, user_id: int) -> Optional[User]:
        """Get user by ID"""
        return self.db.query(User).filter(User.id == user_id).first()
    
    def get_users(self, page: int = 1, limit: int = 20, search: Optional[str] = None) -> PaginatedResponse:
        """Get paginated list of users with optional search"""
        query = self.db.query(User)
        
        if search:
            query = query.filter(
                (User.name.ilike(f"%{search}%")) |
                (User.location.ilike(f"%{search}%"))
            )
        
        total = query.count()
        users = query.offset((page - 1) * limit).limit(limit).all()
        
        return PaginatedResponse(
            items=users,
            total=total,
            page=page,
            limit=limit
        )
    
    def get_question_by_id(self, question_id: int) -> Optional[Dict]:
        """Get question by ID with answers"""
        question = self.db.query(DBQuestion).filter(DBQuestion.id == question_id).first()
        if question:
            # Add answers to question
            question.answers = self.get_answers(question_id=question_id)
            return question
        return None
    
    def get_questions(self, skip: int = 0, limit: int = 10, sort: str = "newest") -> List[DBQuestion]:
        """Get a list of questions with pagination"""
        query = self.db.query(DBQuestion)
        
        if sort == "newest":
            query = query.order_by(DBQuestion.created_at.desc())
        elif sort == "votes":
            query = query.order_by(DBQuestion.votes.desc())
        elif sort == "active":
            query = query.order_by(DBQuestion.updated_at.desc())
        
        return query.offset(skip).limit(limit).all()
    
    def get_total_questions(self) -> int:
        """Get total number of questions"""
        return self.db.query(DBQuestion).count()
    
    def get_questions_by_user(self, user_id: int, page: int = 1, limit: int = 15) -> PaginatedResponse:
        """Get questions by user with pagination"""
        query = self.db.query(DBQuestion).filter(DBQuestion.author_id == user_id)
        total = query.count()
        questions = query.offset((page - 1) * limit).limit(limit).all()
        
        return PaginatedResponse(
            items=questions,
            total=total,
            page=page,
            limit=limit
        )
    
    def get_answers_by_user(self, user_id: int, page: int = 1, limit: int = 15) -> PaginatedResponse:
        """Get answers by user with pagination"""
        query = self.db.query(DBAnswer).filter(DBAnswer.author_id == user_id)
        total = query.count()
        answers = query.offset((page - 1) * limit).limit(limit).all()
        
        return PaginatedResponse(
            items=answers,
            total=total,
            page=page,
            limit=limit
        )
    
    def get_user_stats(self, user_id: int) -> Dict[str, Any]:
        """Get user statistics"""
        user_questions = self.db.query(DBQuestion).filter(DBQuestion.author_id == user_id).count()
        user_answers = self.db.query(DBAnswer).filter(DBAnswer.author_id == user_id).count()
        
        # Calculate total votes received
        question_votes = self.db.query(DBQuestion).filter(DBQuestion.author_id == user_id).with_entities(func.sum(DBQuestion.votes)).scalar() or 0
        answer_votes = self.db.query(DBAnswer).filter(DBAnswer.author_id == user_id).with_entities(func.sum(DBAnswer.votes)).scalar() or 0
        
        return {
            "questions_count": user_questions,
            "answers_count": user_answers,
            "total_votes": question_votes + answer_votes,
            "question_votes": question_votes,
            "answer_votes": answer_votes
        }
    
    def get_answers_by_question(self, question_id: int):
        """Get all answers for a question"""
        return self.db.query(DBAnswer).filter(DBAnswer.question_id == question_id).all()
    
    def get_tag_by_name(self, tag_name: str) -> Optional[Tag]:
        """Get tag by name"""
        return self.db.query(Tag).filter(Tag.name.ilike(tag_name)).first()
    
    def get_questions_by_tag(self, tag_name: str, page: int = 1, limit: int = 15, sort: str = "newest") -> PaginatedResponse:
        """Get questions filtered by tag with pagination"""
        tag = self.get_tag_by_name(tag_name)
        if not tag:
            return PaginatedResponse(items=[], total=0, page=page, limit=limit)
        
        query = self.db.query(DBQuestion).filter(DBQuestion.tags.contains([tag_name]))
        
        if sort == "newest":
            query = query.order_by(DBQuestion.created_at.desc())
        elif sort == "votes":
            query = query.order_by(DBQuestion.votes.desc())
        elif sort == "active":
            query = query.order_by(DBQuestion.updated_at.desc())
        
        total = query.count()
        questions = query.offset((page - 1) * limit).limit(limit).all()
        
        return PaginatedResponse(
            items=questions,
            total=total,
            page=page,
            limit=limit
        )
    
    def get_popular_tags(self, limit: int = 20) -> List[Tag]:
        """Get most popular tags"""
        return self.db.query(Tag).order_by(Tag.count.desc()).limit(limit).all()
    
    def get_trending_tags(self, limit: int = 10) -> List[Tag]:
        """Get trending tags (for demo, return most popular)"""
        return self.get_popular_tags(limit)
    
    def search_questions(self, query: str, tags: Optional[List[str]] = None, skip: int = 0, limit: int = 20, sort: str = "relevance") -> tuple[List[Dict], int]:
        """Search questions by title or content"""
        search_query = self.db.query(DBQuestion).filter(
            (DBQuestion.title.ilike(f"%{query}%")) | (DBQuestion.body.ilike(f"%{query}%"))
        )
        
        if tags:
            # Join with tags table and filter by tag names
            search_query = search_query.join(DBQuestion.tags).filter(Tag.name.in_(tags))
        
        if sort == "relevance":
            # For now, just sort by newest
            search_query = search_query.order_by(DBQuestion.created_at.desc())
        elif sort == "newest":
            search_query = search_query.order_by(DBQuestion.created_at.desc())
        elif sort == "votes":
            search_query = search_query.order_by(DBQuestion.votes.desc())
        
        total = search_query.count()
        questions = search_query.offset(skip).limit(limit).all()
        
        # Convert to dictionary format
        result = []
        for q in questions:
            result.append({
                "id": q.id,
                "title": q.title,
                "content": q.body,
                "author": q.author,
                "tags": [t.name for t in q.tags],
                "votes": q.votes,
                "views": q.views,
                "answer_count": len(q.answers),
                "asked": q.created_at
            })
        
        return result, total
    
    def get_user_by_username(self, username: str) -> Optional[User]:
        """Get user by username"""
        print(f"Searching for user with username: {username}")
        user = self.db.query(User).filter(User.name == username).first()
        print(f"User found: {user is not None}")
        if user:
            print(f"User details - ID: {user.id}, Name: {user.name}, Email: {user.email}")
        return user
    
    def get_user_by_email(self, email: str) -> Optional[User]:
        """Get user by email"""
        return self.db.query(User).filter(User.email == email).first()
    
    def create_user(self, name: str, email: str, hashed_password: str) -> User:
        """Create a new user"""
        user = User(
            name=name,
            email=email,
            hashed_password=hashed_password,
            created_at=datetime.utcnow(),
            updated_at=datetime.utcnow(),
            reputation=0,
            is_active=True,
            is_deleted=False,
            last_seen=datetime.utcnow()
        )
        self.db.add(user)
        self.db.commit()
        self.db.refresh(user)
        return user
    
    def get_question(self, question_id: int) -> Optional[DBQuestion]:
        """Get question by ID"""
        return self.db.query(DBQuestion).filter(DBQuestion.id == question_id).first()
    
    def create_question(self, question: QuestionCreate, author_id: int):
        """Create a new question"""
        from .db.models import Question as DBQuestion, Tag
        print(f"Creating question with: title={question.title}, body={question.body}, author_id={author_id}")
        print(f"Question object fields: {dir(question)}")
        print(f"Question dict: {question.model_dump()}")
        
        db_question = DBQuestion(
            title=question.title,
            body=question.body,
            author_id=author_id,
            created_at=datetime.utcnow(),
            updated_at=datetime.utcnow()
        )
        self.db.add(db_question)
        self.db.commit()
        self.db.refresh(db_question)
        
        # Process tags
        if question.tags:
            for tag_name in question.tags:
                # Check if tag exists, create if not
                tag = self.db.query(Tag).filter(Tag.name == tag_name).first()
                if not tag:
                    tag = Tag(name=tag_name)
                    self.db.add(tag)
                    self.db.commit()
                    self.db.refresh(tag)
                
                # Add tag to question via many-to-many relationship
                if tag not in db_question.tags:
                    db_question.tags.append(tag)
            
            self.db.commit()
            self.db.refresh(db_question)
        
        return db_question
    
    def get_answers(self, question_id: Optional[int] = None, user_id: Optional[int] = None, page: int = 1, limit: int = 20, sort: str = "votes"):
        """Get answers with optional filtering and pagination"""
        query = self.db.query(DBAnswer)
        
        if question_id is not None:
            query = query.filter(DBAnswer.question_id == question_id)
        
        if user_id is not None:
            query = query.filter(DBAnswer.author_id == user_id)
        
        if sort == "votes":
            query = query.order_by(DBAnswer.votes.desc())
        elif sort == "newest":
            query = query.order_by(DBAnswer.created_at.desc())
        elif sort == "oldest":
            query = query.order_by(DBAnswer.created_at.asc())
        
        # Apply pagination
        offset = (page - 1) * limit
        return query.offset(offset).limit(limit).all()
    
    def create_answer(self, question_id: int, user_id: int, content: str):
        """Create a new answer"""
        db_answer = DBAnswer(
            body=content,
            question_id=question_id,
            author_id=user_id,
            created_at=datetime.utcnow(),
            updated_at=datetime.utcnow()
        )
        self.db.add(db_answer)
        self.db.commit()
        self.db.refresh(db_answer)
        return db_answer
    
    def vote_question(self, question_id: int, user_id: int, vote_type: str):
        """Vote on a question"""
        question = self.get_question(question_id)
        if not question:
            raise ValueError("Question not found")
        
        if vote_type == "up":
            self.db.query(DBQuestion).filter(DBQuestion.id == question_id).update({DBQuestion.votes: DBQuestion.votes + 1})
        elif vote_type == "down":
            self.db.query(DBQuestion).filter(DBQuestion.id == question_id).update({DBQuestion.votes: DBQuestion.votes - 1})
        
        self.db.commit()
    
    def vote_answer(self, answer_id: int, user_id: int, vote_type: str):
        """Vote on an answer"""
        answer = self.db.query(DBAnswer).filter(DBAnswer.id == answer_id).first()
        if not answer:
            raise ValueError("Answer not found")
        
        if vote_type == "up":
            self.db.query(DBAnswer).filter(DBAnswer.id == answer_id).update({DBAnswer.votes: DBAnswer.votes + 1})
        elif vote_type == "down":
            self.db.query(DBAnswer).filter(DBAnswer.id == answer_id).update({DBAnswer.votes: DBAnswer.votes - 1})
        
        self.db.commit()
    
    def increment_question_views(self, question_id: int):
        """Increment question view count"""
        question = self.get_question(question_id)
        if question:
            self.db.query(DBQuestion).filter(DBQuestion.id == question_id).update({DBQuestion.views: DBQuestion.views + 1})
            self.db.commit()
    
    def get_site_stats(self) -> Dict[str, int]:
        """Get site statistics"""
        return {
            "total_questions": self.db.query(DBQuestion).count(),
            "total_answers": self.db.query(DBAnswer).count(),
            "total_users": self.db.query(User).count(),
            "total_tags": self.db.query(Tag).count()
        }

    def get_all_users(self) -> List[User]:
        """Get all users from the database"""
        return self.db.query(User).all()

    def update_question(self, question_id: int, question: QuestionCreate):
        db_question = self.get_question(question_id)
        if db_question:
            self.db.query(DBQuestion).filter(DBQuestion.id == question_id).update({
                DBQuestion.title: question.title,
                DBQuestion.body: question.body,
                DBQuestion.updated_at: datetime.utcnow()
            })
            self.db.commit()
            db_question = self.get_question(question_id)  # Refresh the object
        return db_question

    def delete_question(self, question_id: int) -> bool:
        db_question = self.get_question(question_id)
        if db_question:
            self.db.delete(db_question)
            self.db.commit()
            return True
        return False

    def get_answer(self, answer_id: int):
        return self.db.query(DBAnswer).filter(DBAnswer.id == answer_id).first()

    def update_answer(self, answer_id: int, answer: AnswerCreate):
        db_answer = self.get_answer(answer_id)
        if db_answer:
            self.db.query(DBAnswer).filter(DBAnswer.id == answer_id).update({DBAnswer.body: answer.body})
            self.db.commit()
            db_answer = self.get_answer(answer_id)  # Refresh the object
        return db_answer

    def delete_answer(self, answer_id: int) -> bool:
        db_answer = self.get_answer(answer_id)
        if db_answer:
            self.db.delete(db_answer)
            self.db.commit()
            return True
        return False

    def get_tags(self, page: int = 1, limit: int = 20, search: Optional[str] = None, sort: str = "popular") -> PaginatedResponse:
        """Get paginated list of tags with optional search and sorting"""
        # Print out the parameters for debugging
        print(f"DataService.get_tags called with: page={page}, limit={limit}, search={search}, sort={sort}")
        
        query = self.db.query(Tag)
        
        # Apply search filter if provided
        if search:
            query = query.filter(Tag.name.ilike(f"%{search}%"))
        
        # Apply sorting
        if sort == "popular":
            # Sort by popularity (number of questions using this tag)
            query = query.outerjoin(question_tags).group_by(Tag.id).order_by(func.count(question_tags.c.question_id).desc())
        elif sort == "name":
            # Sort alphabetically by name
            query = query.order_by(Tag.name)
        elif sort == "newest":
            # Sort by creation date, newest first
            query = query.order_by(Tag.created_at.desc())
        
        # Calculate pagination values
        total = query.count()
        total_pages = math.ceil(total / limit)
        skip = (page - 1) * limit
        
        # Get the paginated results
        items = query.offset(skip).limit(limit).all()
        
        result = PaginatedResponse(
            items=items,
            total=total,
            page=page,
            limit=limit
        )
        print(f"DataService.get_tags returning PaginatedResponse with {len(items)} items")
        return result

    def get_tag(self, tag_id: int) -> Optional[Tag]:
        return self.db.query(Tag).filter(Tag.id == tag_id).first()

    def create_tag(self, tag: TagCreate) -> Tag:
        db_tag = Tag(name=tag.name)
        self.db.add(db_tag)
        self.db.commit()
        self.db.refresh(db_tag)
        return db_tag

    def update_tag(self, tag_id: int, tag: TagCreate):
        db_tag = self.get_tag(tag_id)
        if db_tag:
            self.db.query(Tag).filter(Tag.id == tag_id).update({Tag.name: tag.name})
            self.db.commit()
            db_tag = self.get_tag(tag_id)  # Refresh the object
        return db_tag

    def delete_tag(self, tag_id: int) -> bool:
        db_tag = self.get_tag(tag_id)
        if db_tag:
            self.db.delete(db_tag)
            self.db.commit()
            return True
        return False

    def add_tag_to_question(self, question_id: int, tag_id: int) -> bool:
        question = self.get_question(question_id)
        tag = self.get_tag(tag_id)
        if question and tag:
            stmt = insert(question_tags).values(question_id=question_id, tag_id=tag_id)
            self.db.execute(stmt)
            self.db.commit()
            return True
        return False

    def remove_tag_from_question(self, question_id: int, tag_id: int) -> bool:
        stmt = delete(question_tags).where(
            question_tags.c.question_id == question_id,
            question_tags.c.tag_id == tag_id
        )
        result = self.db.execute(stmt)
        self.db.commit()
        return result.rowcount > 0
